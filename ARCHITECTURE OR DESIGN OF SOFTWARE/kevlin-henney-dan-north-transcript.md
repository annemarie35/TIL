Transcription

Welcome to the Modern Software Engineering channel and to One Big Question. If you like this, give us a like. And if you want more of stuff like this, be sure to subscribe to the channel. My name's Kevlin Henney, and I'm here with Daniel Terhoss North, and we are going to answer one big question. And the one big question we're going to explore today, and by the way, let's be clear, we're not going to give you a simple answer. We're going to explore the question. **The question here is, is clean code a myth that we tell ourselves**? 
Daniel, where do we start on this one? Well, always with terms. So clean code itself. I'm going to start by being you, or at least by channeling you. You wrote a delightful post recently exploring the origins of the term clean code. And I need to say, for folks that don't know Kevin, he does this really well in his talks and his writing. Some people call him the history guy. I describe him as the context guy. That when something is happening in the software world, in the technical world, There's an awful lot of standing on the shoulders of giants. I think a lot of that goes unacknowledged, sometimes deliberately, but mostly accidentally. And one of the things that Kevin does really well is surfaces. Well, hang on. That's a reference to this 1973 paper that three people have ever read. And I'm the fourth one. So for me, I have kind of three vectors, if you like, three sources for clean code. There's probably the one most people will be familiar with is Robert C. Martin's book, Clean Code, from the, I think, early 2000s, thereabouts, 20-something years. 2008. 2008. Wow, later than I thought. Okay, so from the late noughts. Then much more recently, Kent Beck has been writing a wonderful series that he's calling Tidy, Tidy First. Part of that, I suspect, is to differentiate from clean as a term and not to muddy the waters any further. But then for me, and again, this is because a lot of my, I'm not going to lie, a lot of my software thinking has been informed by Kevlin over decades. is Richard Gabriel, Dick Gabriel, who wrote a series of articles. I published it as a book that Kevin got me onto. And Dick Gabriel uses this term **habitability**. And he talks about habitable code and habitable code has two characteristics. One is comfortable. So you are comfortable moving around in it. So as opposed to uncomfortable, scared, nervous, whatever. And the other characteristic is confident. You're confident to make a change. And if you're comfortable navigating code and confident to make a change in code, I'm like, that's a good place to be. And in fact, that was my launching point for Cupid, which was my attempt at joyful code a few years back. Was, okay, so Martin Fowler talks about people should be able to, people should write code that humans can understand. I'm like, understandable is good. Habitable is better. Can we get to joyful? So I have these sort of three axes of clean. There's the Bob Martin's patterns and book. There's Kent's kind of more recent riff of tidy. And then predating all of those by some time is Dick Gabriel talking about habitability. Yeah. In fact, I think the really interesting thing, there's a number of things you teased apart there. One of which is, thank you. The other of which is I didn't have the Dick Gabriel book to hand and I just retidied my office. So I have no idea where that book is at this point. I can't reach it easily. But that book is interesting. And I think the idea with habitability that I like so much is that it describes an experience. It's actually more to do with the relationship between the developer and the code base and the ecosystem than it is necessarily of the distinct practices within the code. That's not to say they're not important, but it sort of tells you where you want to evaluate it. And it's not necessarily in the code, it's a within and around the relationships to the code. And habitability I love as a metaphor because it invites you to think of architecture as a place where, you know, people live, which, funnily enough, is actually the original point of architecture. What is the experience of being here? And I think we forget that as well. But I think also the idea of moving from just static properties of the code to the experience, and exactly as you say, the Cupid joyfulness, I think is a really interesting way of exploring that. And it goes clearly beyond an idea of cleanliness. It kind of almost invites this kind of idea of the metaphor. When we're talking about these things that are abstract, We're always looking for something that gives us a new insight or the vocabulary to talk about things because code and software is remarkably non-physical. And I think there's another distinction that you brought up that I thought was really good when we were talking about clean code before in a chat was there is a kind of a difference between clean code Capital C, capital C, TM, which we might associate with Robert Martin and some of the practices that are associated with that kind of view of Cody. And sometimes people feel and have reacted to, I've noticed in the public space, that there's a little bit dogmatic there. And that's a lot of people react against that, which is understandable. They're not necessarily reacting directly to the guidelines or perhaps the intentions that other people have, but very much the apparent dogma, which nobody likes that. And then clean codes. just as a general description. And this was an interesting thing. Going through the history of this and a recent discussion triggered this and caused me to go back and say, well, where has this term come from? Because there was this impression for a number of people, a number of people I've trained, they have this kind of point of origin. Oh yeah, CleanCo. It was invented by Robert Martin, and often there is a sense that it was further back than it was, which, by the way, for anybody watching, is the opposite of what happens with music. Whenever anybody says, can you remember this track? You always get it wrong by thinking it's more recent. It turns out for some of these things, we get them wrong the other way. And one of the things that I found is that I was pointing out, no, no, no, this term was already in the air before it got, as it were, captured and nailed down. It was already... It wasn't... It was suggestive. It wasn't a, when I say clean code, I mean all of these practices. It was slightly better. It was trying to associate, for example, with the idea that refactoring is a form of hygiene. And that's refactoring, the hygiene metaphor that Martin Fowler often uses, that idea of, it's the idea of you brush your teeth and you shower on a regular basis. You don't save it up for once a year. you know, and then go and see your friends. Because you won't have any friends by that point. That's what I'm doing wrong. This is kind of like a daily and continuous practice. I've got to say, this is an uncomfortable way to learn this about myself, but there we go. Like we said, one big question, lots of knowledge. So this is the interesting thing is I found that with my training in TDD, I quote, so let's go back to Kent. 

And I quote the beginning of this book from Kent, Test Driven Development by Example. And this book was published in 2003. So that is a generation ago. But the interesting thing is right there in the beginning, the opening sentence is, in fact, the opening words, clean code. Clean code that works in Ron Jeffrey's pithy phrase is the goal of test driven development. And then he describes why it's a worthwhile goal and enumerates the qualities and the, again, funnily enough, the experience. But he also clarifies, he talks about it from Ron Jeffrey's point of view, and he also clarifies something that often people sort of say, yeah, your code's clean, but it doesn't work. He says, well, the phrasing is clean code that works. You know, so he is talking about it from an experiential, but also a much more complete perspective. I then found that, given that I mentioned Martin, the original version of Refractory, Martin uses the terminology clean code extensively. So I think what, okay, this takes us back to the 1990s. It's just like, we're in the 1990s. And I started thinking, again, Kent's work, a lot of his work was about this kind, vocabulary has changed at various times. But I thought, you know, I think it was in the air before that. So I did a bit of digging around and here is my copy of **The Elements of Programming Style**. Of course it is. This was published in the 1970s. Okay. So this is, I actually learned from this. This is a second edition, late 70s. That's a cardboard mock-up, isn't it? That's not a real book. damn rumbles um people this just as a point this book is really slim because people did not get into the slightly cynical game back then of publishing books with thick paper so that they took up more um space in the bookshelf and there are publishers that really specialize in this so this is um it's 130 odd pages yeah it's about 130 or so pages and i learned an immense amount from this book. It was written in the late 70s. The original, and this is the thing, I found the first edition, 1974, clean code. And they use the phrasing clean code. They use clean as a verb. They also use, they use clean code as a noun phrase. And it's there. And again, they're not saying this is clean code and here enumerating a set of practices. They're just using it as a suggested metaphor rather than just something bland like good or also moral in that sense. And I think that's really important because I think that a lot of people have come to think of clean code, they either gravitate towards the phrase and therefore the branding, or they are repelled by it exactly. that they are either drawn to it or repelled by it, or repelled by it. They have an opinion, yeah. Yeah, they have an opinion. And the problem is, I don't think we really want to, that's really not the original goal. I mean, I can read these things and they kind of, yeah, I'm with you, I'm with you all the way. And so that kind of gets us to this interesting question that perhaps we need to distinguish when we're talking about clean code. Are we talking about a particular set of practices and opinions? Or is it suggestive and connects to something bigger, as you say, things like habitability? Or that question, that very simple question, we are ultimately human, Does this bring me joy? You know, when I work in this code base, when I work with these people, when I work in this arc, is that bringing me joy or am I constantly frustrated? And so therefore it's a very human thing rather than merely something code. It's like clean code is the start of the conversation, not the end. Well, and this is what I want to pick up on because, you know, you don't have clean code for the sake of, you have clean code in order to. And so I see it as very much as relational. It's relationship between the programmer and the code. And I've heard the term hygiene a lot. I think of hygiene, when folks like Martin use the word hygiene, I think of it less in the sense of personal hygiene and more in the sense of hygiene of a kitchen. So hygiene of a place in which you want to do something where cleanliness is an important part of doing the thing. So a surgical operating theater or a kitchen or something. And when you look at the way a high-performing kitchen works, like a professional kitchen, a restaurant kitchen, then what you see is many, many, many small habits repeated again and again and drilled into people, right? You wash up as you go. You put things away as you go. You don't put the cooked meat next to the raw meat. They live in different fridges, different containers. And so there are certain rules that have grown up around this, not because we like rules, but because they keep us safe. And if I think of code hygiene, it's not, and this is where you get into the, I tend to push back on the more dogmatic kind of, you have to have this many lines in a function or, you know, the separation of concerns that everyone gets wrong. I'll come back to that. I've got a good rant about that. Oh, yeah. I'm with you on that one. I will co-rant. Right, right. But the idea that we want clean in order to, hygienic in order to, and it's a relationship between people and code. And that brings me to a lot of the specific advice in the clean code book. You know, we talk about things aging like milk or aging like fine wine, right? And a lot of the advice that, interestingly, because I read, I read clean code. I had never read it. Dave Farley has something, I think it's just come out on the Modern Software Engineering channel, where he's comparing Bob Martin's take on clean code with his take on modern software engineering and how they compare and contrast. And I think he's done a very even-handed job, I must say. I think he's been very, very fair. And what I find in, so one of the things he says is it's never really impacted him one way or the other. He's kind of lived his professional life independent of this book, but he decided to go and look at it. And I did the same a few years ago. I took it on holiday and I read it. I'd never read it. And oh my word, my Kindle has many, many notes from reading this book. And most of them are what or no or things like that. And some of them, so I'm going to name names. There's, so it's an anthology book. So a lot of the chapters he wrote himself, a number of the chapters are invited. James Grening, the C embedded systems guy. wrote a chapter on boundaries and my Kindle notes say an oasis of clarity in a sea of I won't say what the rest of the sentence is, but basically it's a beautifully written little paper about Identifying boundaries. I mean you could derive the whole of domain driven design from first principles from this chapter It's gorgeous Tim Ottinger again contributed a chapter on naming and naming things is hard one of the three great problems and And again, it's beautifully written, very actionable, really good advice. And so in this book is some really good stuff, some stuff that stood the test of time. In it also is some shocking advice. And my kind of analytical brain kind of started chewing on this. Like, why would this be? And there's, I'm a Christian. I spent a lot of time poking around in the Bible. And there's a way of studying ancient texts called hermeneutics. And there's another word as well. I'll just escape in a minute. But hermeneutics is where you say, okay, what was true at the time that this thing was written? What was the context of this thing at the time? And exegesis, that's the other part. And then if I were then to extrapolate that to now, what would it be? So Jesus tells loads of parables about fishing, right? He's a big, he's got a lot of stories about fishing. Yeah. Why? Well, because that was one of the main industries. Most of the people he was talking to either were fishermen, knew fishermen, had fishermen in the family. Fishing was a big deal. They were on the Sea of Galilee. And okay, what might you compare, if he was telling those stories now, what might they be? It could be, I don't know, office type work or whatever would be a reasonable comparison. And so I'm looking at this, I'm looking at clean code. I'm thinking, okay, so what is true? So what would need to be true such that the advice that you take this code and break it into lots of small pieces break it. And it's, it's not, it's, it's, it's more, it feels to me more extreme than coupling and cohesion and separation and all that. It feels more, more militant than that. And if you play back to like the late 90s, early 2000s, when all of this stuff was happening, you would have requirements coming into a team and the requirement might be, okay, we need to put some new content on this report. So Kevlin, you're doing the health reporting subsystem and we need to put a new piece of information in this report. We need to add some more details about the doctor. And we go, okay, right. what work needs to happen, whether it's some UI work, we need to add some fields in the user interface, we need to make some database changes, we probably need to populate that database with some default values, we need to make some change to some of the service stuff, the rendering logic needs, so I ended up with this big pile of work, right? Now, in the 90s, that work would have been farmed out to different teams. And they might not even have been in the same building. So a requirement would not have been add this field to this report. It would have been make this database change, make this service change, make this UI change, make this rendering change. And what you don't want is the people who are doing that, ideally fairly close to each other in time, tromping all over each other's code changes. And so the way you do that is admin, right? You move the code into different places so they're less likely to crash into each other. Now you play that forward 5, 10, 25 years, and you now have Kevlin. Kevlin is Mr. Full Stack, right? And Kevlin gets the requirements to change, to add the field to the form, and he goes in and changes the UI, changes the database, changes the schema, writes an automated database migration to move that forward, writes the test. So now the one person or the one team is going to do all of that work. It doesn't get split out anymore. It doesn't get spit out and farmed out anymore. So what do we have now with all that code all scattered around the place? What we have now is an administrative problem, right? Is I've made it more work, right? If all of that stuff, if all of the stuff about the reporting form fields was in the same bunch of code in the same bunch of areas, then I can navigate that really easily and really quickly. Again, making it socio-technical, making it about humans and code. How should we structure the code that makes it easiest to make sense of, to navigate, to change comfortably and confidently? How do we make the code habitable? And it turns out breaking it into 30 different places is no longer the answer. But if we project that forward, having good names is still the answer. Having good boundaries is still the answer. So some parts of that have aged like wine. Some parts of it have aged in the same way that they're relevant in a different era. I'm going to pick up on a couple of points that you mentioned. The point about James Groning, he wrote a lovely book on... Tester and Development for Embedded C. And there's a couple of things I really like about that book. One is... Which is a brave thing to try, let alone write a book about. Exactly. First of all, that's sometimes when I'm talking about TDD for people, mad props to the man. People say, oh, we can't do this. And he's a lovely human being as well. I mean, he's a genuinely lovely human being. But there's a point in that book. There's a couple of paragraphs I quote that capture the flow. And he also talks about a joyfulness as well. There's a paragraph where I think he calls it the physics of TDD. And there's a kind of a simple paragraph where in that paragraph, you have everything you ever wanted to know about what you want from a workflow. But it starts with fun. And then we go into the technical aspects and we talk. And he manages to, it's a really nice, so very quotable and I use it. So I use that. But I also, the book is an existence proof. If somebody says, oh, we can't do this in our environment. I say, is your environment more or less extreme than Embedded Sea? Because if it's less, then I think you probably can. Because here's a whole book on how to do it in this hard, hard environment. So there's that. But that point very much about finding boundaries. And you hit on something I think that's really important. It's often about boundaries and there's also acknowledgement. You talked about the standing on shoulders. You mentioned the Tidy First book. Kent, in the intro to Tidy First, talks about kind of the story about how he got here. And he refers to, guess what, I've also got this book. Just for folks, I was not developing software in the 1970s. I just like old books, okay? I just dig around. So this one, Structured Design from Jordan and Constantine. And Kent refers to this, and he talks about it and the origins and how it made him think and how he spots. And again, these books, and I do quote from this and a couple of other books, where... They are talking very much... They don't use the term habitability, but they are very much talking about modularity as a kind of human experience, about understanding and readability. They're relating it to us, and that's a really important idea. So our boundaries, and going back to naming, boundaries are important in naming, so that we can... It helps us group these ideas. In other words, these are there to facilitate your thinking and how you construct a mental model. When you are reading the code, code is one of the weirdest things we have as humans do. We're literally trying to take an idea from one head and transplant it in another. And it's not just suggestive. It's got to be precise as well. So we're trying to... pursue these many almost contradictory goals. But the thing I like about that point of view is that we do have the, you sort of described it from a point of view of the time, but I'm going to remember back to the 90s and 2000s and go, yeah, people weren't even doing that. Or was that even the right response then? And so the problem that we recognize and we recognize now is like, yeah, at Legacy Co., one of the characteristics is big, long, messy methods and all the rest of it. And that's a bit like saying, oh, this is really big. The problem is the bigness. Yes, we solve it by breaking everything into small pieces. Not necessarily. What you want to do is do something that causes small pieces rather than aim for small pieces, if that makes sense. Yes, yes, yes, absolutely. Yeah, and it's actually something I said to somebody a few years ago. And so, can I sort of jump in there? It's really important. Small is about how much thinking you have to do, not about how much code there is. Yes. So small is about, now there's a term that has become massively overused. Let's talk about Perl. No, let's not talk about Perl. I've written production systems in Perl 5. There's a term that's become massively overused. I get a lot of semantic diffusion, which is cognitive load. And I'm not going to get into why I think it's been misused now or the context in which it's being misused. But effectively, as a heuristic, how much mental effort, how much mental juggling I have to wrap my head around something and the kind of the contra of that, which is how easy it is for me to accidentally mess something up in that thing, right? That is the bigness thing. Now it might be, and I've seen this, I've worked with code bases where you were looking at a lot of code at one time And it all made perfect sense, and it was completely easy to navigate. It was that comfort thing again, Dick Gabriel's comfort thing. I've also looked at small bits of code, and not necessarily because it's a high-density language like Haskell or APL or something, just code that was really bonkers written. So within a few lines of code, there's so many different things trying to happen as scream and fail and stuff. Yeah. That you need to unpack it into something that you want to make it bigger so that it will fit in your head. Yeah. Make it more verbose. Yeah. So there's an interesting thing here. So it's one of the things that a few years ago I wrote up and I gave workshops at a particular environment. I came up with this idea in the early 2000s based on a particular consultancy with a client, but it's a programmer's dozen. I have 13 pieces of advice and somebody... I remember your programmer's dozen. So I recall there were several programmers, dozens. It evolved. Oh, no, no. It was actually pretty much, it stayed very, very stable. But what was interesting is one of the comments I had from somebody said, oh, you never recommend that our functions should be small. And I said, no, by doing this, you get small functions. Do not have the tail wag the dog, yes. Exactly. And that, I think, is part of the issue. And you talk about the information density, which I think is really important. And you also talk about the idea that something can be all in one place and it all makes sense. And that led me to a realization a few years ago when talking to somebody and they were talking about breaking stuff up and stuff. And I said, well, the thing is here, you're treating it as like a linear relationship, more is bad, less is good. And I said, actually, it's a bit more Goldilocks. One of the problems we have, some code I saw the other week, there was a function that was over a thousand lines long, and I can't remember the levels of indentation. I'm not going to put a magic number to it, but let's just say, I'm going to say that's too big. This poor brain can't handle everything all in one place. Does it hurt to read the function? If it hurts to read the function, it's probably too big. am i waiting too late you know do i genuinely have to keep my finger down to get to the end you know because sitting there yeah are we there no we're not there am i seeing the left margin do this i once actually once it was a 1500 liner i once had the experience of going down uh going down a function and then i got a blank screen because the indentation took it outside my window wow yeah i know everybody yeah i love that story because that's the story that started me down zooming things to the smallest point size to just look at the landscape and the shape of the coat But the thing there is that one of the issues that we have, and this is kind of a problem of like, I have so many things in one place, mentally I have to tease them apart in order to understand it. I am mentally decomposing and deconstructing all of this. But we also have potentially the opposite problem. As we start to actually realize that, rather than just do it in our head, do it in the code, if we keep on pulling everything apart, we end up with the opposite problem, fragmentation. All the pieces are all over, and in order to understand it, I have to put them back together again. So I'm now doing the opposite. So there's somewhere in the middle, and it's not a point, it's going to be a zone, and it's going to be different for different people at different times. But there is this idea of, am I looking at the code and I'm mentally, there's so much going on, I'm trying to pull apart what I'm seeing. And then at the other end of the scale, are there so many pieces lying on the floor? I'm mentally having to try and put them recompose in my head rather than having it presented. So for me, exactly that, that, that the fitting in the brain, that comprehensibility, you can have something that rather than mandating a magic number for the number of lines is what's going on here. How am I, you know, what is the, am I having to pull stuff apart or recompose? Am I constantly hunting around my code for fragmented methods and that bookkeeping? Yeah. That I think is an issue. The clean code, a lot of the guidelines in clean code lead to, arbitrarily they put limits and they lead to fragmentation. And I don't want fragmented thinking, but I also don't want to have the problem of overwhelm. So you end up with, you're looking for that balance and therefore it's that Goldilocks zone. And that for me is a much, again, it goes back to that point you made about the experience. It's a relational thing. And that's what we're after. That's the habitability. That's where I find the comfort. My house has rooms. It does not have small boxes that I've broken everything into. It has roots. But if I put all of the junk into one big room, that's too much. But if I break everything into tiny, tiny rooms that I can barely get into, maybe that's a little bit too small. But there is a kind of a hierarchy and a balance of understanding. I think that's kind of an important one. Can I offer you a lovely phrase I came across a little while ago? There's an ultralight web framework called HTMX. And HTMX is trying to be effectively the antidote to your React and your Angular's. I'm not going to mention many technologies, but if our viewers haven't seen it, go and check it out. Not least because the main author has a very, very good meme game on social media, but also there's some really great essays in there on case studies. But what he talks about is his kind of counter to separation of concerns, where you get all these little React bits or Rails bits or whatever, all scattered all over the place. He calls it locality of behavior, L-O-B. And I hadn't heard this phrase, and I really like it. Locality of behavior is bringing together all the things that are that field on your report. You don't keep the database stuff with the database stuff. You keep this field of the report stuff together. And for me, this is kind of an inversion of separate the single responsibility in the solid sense, in the Bob Martin sense is, you know, breaking out layers or breaking out different things. So the database stuff goes over here and the service stuff goes over here and the UI stuff goes over there. And you end up with the, you know, the Rails type, the top level is telling you your framework architecture rather than your product architecture is rather than thinking of single responsibility, think about single goal. So if I think about the single goal principle, which I just coined, I think I just invented it. Yeah. Okay. Folks, you heard it here first. I heard it here first. Exclusive Monosoft for Engineering channel. Single goal principle is assuming I want to achieve a goal, are all of the pieces that I need to achieve that goal close to hand? Because if they are, it's going to make it easy for me. And then we can get onto, and we're probably over time at this point. We are, but no worries. I wanted to mention, I wanted to tie in, I think it's really important, theory of constraints. So since we're doing old stuff, a 1984 book by Eliyahu Goldratt, The Goal, which a few years ago came out as a graphic novel, which I'm very excited about. Oh, do you know, I didn't know that bit. Yeah, no, it's amazing. They did it properly. I think it's like one of the Marvel illustrators. to do the artwork. So it's a proper graphic novel. It's done so well. And what they've done, I know you know the book, is essentially the book operates in two levels. Yeah, of course you have. I knew it was near me. I can remember that one. In fact, I was talking to someone about this recently, so I happened to have it on my desk. Brilliant. The graphic novel. Um, so, so it's a story of a chap called Alex who runs a factory and he's given 30 days to turn the factory around. Otherwise they're going to shut it down and fire everybody. And his marriage is on the rocks and the dog's dying and it's all going wrong for Alex. Right. And the story is about how Alex, uh, bumps into an old school teacher and they have this kind of Socratic questioning type relationship and he. He guides Alex through learning about what turns out to be theory of constraints and flow. And he saves the day. Spoiler, the dog doesn't die. But the brilliant thing is, so you've got the story, the actual plot of quite a fun story, as well as some quite deep principles about management theory. And what the graphic novel does brilliantly is that all of the story happens in the pictures and all of the theory happens in the dialogue. So it's so well done. They really did think it through. Anyway, the point about theory of constraints is this, is in any system, And he has a factory system, but it applies to product development system, it applies to any system of work. If you look at how value is created, there is one thing right now that is the pinch point. There is one thing right now that is limiting the flow of value. And from that, he makes two observations. He says, if you optimize anything downstream of that constraint, then it makes no difference. because nothing's coming through the pipe. If you optimize anything upstream of the constraint, you just make it worse, right? Because they are creating more of a backlog at the constraint. So the only place to work is the constraint. And so the whole theory of constraints model is identify the constraint, which is often harder than you think, because where you're seeing the problem might be presenting symptoms. It might not be the constraint. You know, we have a bottleneck of testing, right? Does that mean that you need more testers or does that mean you need to write code that needs less testing? You have an upstream quality problem, not a downstream number of testers problem. So identify the constraint, then it says, elevate the constraint. So exploit the constraint. So exploit the constraint is, okay, we know that's our limit. Is it running at capacity? Because if it isn't, we've got spare capacity. Now we elevate the constraint, make it the most important thing. Right, now we alleviate it. So now we stop it being the constraint. And what that means is it's like whack-a-mole. The next constraint will appear somewhere else. So for me, when we talk about like bringing this right back to the big question, is clean code a myth? We don't, and this goes right back to your 1970s references. Code cleanliness, code hygiene, kitchen hygiene in and of itself isn't a thing. Hygiene in a kitchen is there in order to serve food sustainably, quickly, effectively. right? We want to be able to deliver software sustainably, quickly, effectively. And most of that for most of the time is changing existing software rather than writing new software. So that means we want existing software to be able to change it quickly, effectively, sustainably. And so the cleanliness of code should be And this is, I make a reference to something else I've been talking about recently, which I call a best simple system for now. The cleanliness of code should be entirely a function of what it is we're trying to do with the code. If it's more clean than that, if you like, then we've over-engineered and that's opportunity cost. We could have been doing something somewhere else. But if the clarity of that code, the cleanliness of that code, the navigability of that code is what's slowing us down right now, we absolutely need to elevate that constraint. I think let's pick that one up in terms of the idea of context. In other words, the cleanliness. So I guess to answer the one big question is that cleanliness is not so much a myth, but it is not a fixed point. It is a relational thing. In other words, it is the idea of exactly as you described it. If we want to make it that, it's not a set of specific co-practices. Although those can contribute, that's your toolkit. Your judgment of your code is going to be something to do with the context. Is this slowing us down? Is this making us miserable? And if the answer is yes, then let us change our balance of tools, look at it differently, take a step back and rearrange things. That, of course, presupposes that we don't like being slow and miserable. Of course, you're right. That's probably the subject of a number of other videos. But I also like the way that you brought out principle of locality in terms of behavior. Principle of locality is what drives my Goldilocks model. I often use that. I say, oh, you might have heard of principle of locality to do with caching and some of that. I say, actually, it's to do with us, but specifically behavior. I think it's a lovely way of looking at it. And I think there's a lot of stuff we want to talk about in future in terms of things like Solid, Cupid, and stuff like that. But folks... That is a different video. Time has caught us. Yeah, time has caught us. We're going to land this plane right here. Hopefully we've explored that question, either to your satisfaction or to your frustration. Let us know. Throw something into the comments. Give us a like if it provokes some thinking and some thoughts. And don't forget to follow the channel. And for the moment, in that case, wherever you are and whenever you are, have a good rest of day. And thank you very much, Daniel. Thank you, Kevlin. What I would add as well, I mean, please, please put your thoughts in the comments. One of the things that we do as a team and as individuals, we look at these comments and they often inspire future One Big Questions, future sessions on the channel. So we absolutely love your feedback.